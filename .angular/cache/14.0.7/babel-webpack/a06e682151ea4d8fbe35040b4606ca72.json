{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { VERSION, InjectionToken, Injectable, Injector, Optional, Inject, NgModule } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@auth0/auth0-spa-js';\nexport { InMemoryCache, LocalStorageCache, User } from '@auth0/auth0-spa-js';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, pluck, first } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { Location } from '@angular/common';\nvar useragent = {\n  name: '@auth0/auth0-angular',\n  version: '1.10.1'\n};\n\nclass Auth0ClientFactory {\n  static createClient(configFactory) {\n    const config = configFactory.get();\n\n    if (!config) {\n      throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n    }\n\n    const {\n      redirectUri,\n      clientId,\n      maxAge,\n      httpInterceptor\n    } = config,\n          rest = __rest(config, [\"redirectUri\", \"clientId\", \"maxAge\", \"httpInterceptor\"]);\n\n    return new Auth0Client(Object.assign(Object.assign({\n      redirect_uri: redirectUri || window.location.origin,\n      client_id: clientId,\n      max_age: maxAge\n    }, rest), {\n      auth0Client: {\n        name: useragent.name,\n        version: useragent.version,\n        env: {\n          'angular/core': VERSION.full\n        }\n      }\n    }));\n  }\n\n}\n\nconst Auth0ClientService = new InjectionToken('auth0.client');\n\nclass AbstractNavigator {\n  constructor(location, injector) {\n    this.location = location;\n\n    try {\n      this.router = injector.get(Router);\n    } catch (_a) {}\n  }\n  /**\n   * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n   * to `window.history.replaceState`.\n   * @param url The url to navigate to\n   */\n\n\n  navigateByUrl(url) {\n    if (this.router) {\n      this.router.navigateByUrl(url);\n      return;\n    }\n\n    this.location.replaceState(url);\n  }\n\n}\n\nAbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) {\n  return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n};\n\nAbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AbstractNavigator_Factory() {\n    return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR));\n  },\n  token: AbstractNavigator,\n  providedIn: \"root\"\n});\n\nAbstractNavigator.ctorParameters = () => [{\n  type: Location\n}, {\n  type: Injector\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc1.Location\n    }, {\n      type: ɵngcc0.Injector\n    }];\n  }, null);\n})();\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\n\n\nfunction isHttpInterceptorRouteConfig(def) {\n  return typeof def !== 'string';\n}\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\n\n\nclass AuthClientConfig {\n  constructor(config) {\n    if (config) {\n      this.set(config);\n    }\n  }\n  /**\n   * Sets configuration to be read by other consumers of the service (see usage notes)\n   * @param config The configuration to set\n   */\n\n\n  set(config) {\n    this.config = config;\n  }\n  /**\n   * Gets the config that has been set by other consumers of the service\n   */\n\n\n  get() {\n    return this.config;\n  }\n\n}\n\nAuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) {\n  return new (t || AuthClientConfig)(ɵngcc0.ɵɵinject(AuthConfigService, 8));\n};\n\nAuthClientConfig.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthClientConfig_Factory() {\n    return new AuthClientConfig(i0.ɵɵinject(AuthConfigService, 8));\n  },\n  token: AuthClientConfig,\n  providedIn: \"root\"\n});\n\nAuthClientConfig.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [AuthConfigService]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthClientConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [AuthConfigService]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\n\n\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n/**\n * Tracks the Authentication State for the SDK\n */\n\nclass AuthState {\n  constructor(auth0Client) {\n    this.auth0Client = auth0Client;\n    this.isLoadingSubject$ = new BehaviorSubject(true);\n    this.refresh$ = new Subject();\n    this.accessToken$ = new ReplaySubject(1);\n    this.errorSubject$ = new ReplaySubject(1);\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n\n    this.isLoading$ = this.isLoadingSubject$.asObservable();\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when the access token has changed.\n     */\n\n    this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => {\n      return {\n        previous: acc.current,\n        current\n      };\n    }, {\n      current: null,\n      previous: null\n    }), filter(({\n      previous,\n      current\n    }) => previous !== current));\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when an event occurs that needs to retrigger the User Profile information.\n     * Events: Login, Access Token change and Logout\n     */\n\n    this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter(loading => !loading), distinctUntilChanged(), switchMap(() => // To track the value of isAuthenticated over time, we need to merge:\n    //  - the current value\n    //  - the value whenever the access token changes. (this should always be true of there is an access token\n    //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n    //  - the value whenever refreshState$ emits\n    merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n\n    this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n\n    this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getUser() : of(null)));\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n\n    this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n\n    this.error$ = this.errorSubject$.asObservable();\n  }\n  /**\n   * Update the isLoading state using the provided value\n   * @param isLoading The new value for isLoading\n   */\n\n\n  setIsLoading(isLoading) {\n    this.isLoadingSubject$.next(isLoading);\n  }\n  /**\n   * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n   * reflect the most up-to-date values from  Auth0Client.\n   */\n\n\n  refresh() {\n    this.refresh$.next();\n  }\n  /**\n   * Update the access token, doing so will also refresh the state.\n   * @param accessToken The new Access Token\n   */\n\n\n  setAccessToken(accessToken) {\n    this.accessToken$.next(accessToken);\n  }\n  /**\n   * Emits the error in the `error$` observable.\n   * @param error The new error\n   */\n\n\n  setError(error) {\n    this.errorSubject$.next(error);\n  }\n\n}\n\nAuthState.ɵfac = function AuthState_Factory(t) {\n  return new (t || AuthState)(ɵngcc0.ɵɵinject(Auth0ClientService));\n};\n\nAuthState.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthState_Factory() {\n    return new AuthState(i0.ɵɵinject(Auth0ClientService));\n  },\n  token: AuthState,\n  providedIn: \"root\"\n});\n\nAuthState.ctorParameters = () => [{\n  type: Auth0Client,\n  decorators: [{\n    type: Inject,\n    args: [Auth0ClientService]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }];\n  }, null);\n})();\n\nclass AuthService {\n  constructor(auth0Client, configFactory, navigator, authState) {\n    this.auth0Client = auth0Client;\n    this.configFactory = configFactory;\n    this.navigator = navigator;\n    this.authState = authState;\n    this.appStateSubject$ = new ReplaySubject(1); // https://stackoverflow.com/a/41177163\n\n    this.ngUnsubscribe$ = new Subject();\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n\n    this.isLoading$ = this.authState.isLoading$;\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n\n    this.isAuthenticated$ = this.authState.isAuthenticated$;\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n\n    this.user$ = this.authState.user$;\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n\n    this.idTokenClaims$ = this.authState.idTokenClaims$;\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n\n    this.error$ = this.authState.error$;\n    /**\n     * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n     * but only **after** `handleRedirectCallback` is first called\n     */\n\n    this.appState$ = this.appStateSubject$.asObservable();\n\n    const checkSessionOrCallback$ = isCallback => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n\n    this.shouldHandleCallback().pipe(switchMap(isCallback => checkSessionOrCallback$(isCallback).pipe(catchError(error => {\n      const config = this.configFactory.get();\n      this.navigator.navigateByUrl(config.errorPath || '/');\n      this.authState.setError(error);\n      return of(undefined);\n    }))), tap(() => {\n      this.authState.setIsLoading(false);\n    }), takeUntil(this.ngUnsubscribe$)).subscribe();\n  }\n  /**\n   * Called when the service is destroyed\n   */\n\n\n  ngOnDestroy() {\n    // https://stackoverflow.com/a/41177163\n    this.ngUnsubscribe$.next();\n    this.ngUnsubscribe$.complete();\n  }\n  /**\n   * ```js\n   * loginWithRedirect(options);\n   * ```\n   *\n   * Performs a redirect to `/authorize` using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   *\n   * @param options The login options\n   */\n\n\n  loginWithRedirect(options) {\n    return from(this.auth0Client.loginWithRedirect(options));\n  }\n  /**\n   * ```js\n   * await loginWithPopup(options);\n   * ```\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   *\n   * IMPORTANT: This method has to be called from an event handler\n   * that was started by the user like a button click, for example,\n   * otherwise the popup will be blocked in most browsers.\n   *\n   * @param options The login options\n   * @param config Configuration for the popup window\n   */\n\n\n  loginWithPopup(options, config) {\n    return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n      this.authState.refresh();\n    }));\n  }\n  /**\n   * ```js\n   * logout();\n   * ```\n   *\n   * Clears the application session and performs a redirect to `/v2/logout`, using\n   * the parameters provided as arguments, to clear the Auth0 session.\n   * If the `federated` option is specified it also clears the Identity Provider session.\n   * If the `localOnly` option is specified, it only clears the application session.\n   * It is invalid to set both the `federated` and `localOnly` options to `true`,\n   * and an error will be thrown if you do.\n   * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n   *\n   * @param options The logout options\n   */\n\n\n  logout(options) {\n    const logout = this.auth0Client.logout(options) || of(null);\n    from(logout).subscribe(() => {\n      if (options === null || options === void 0 ? void 0 : options.localOnly) {\n        this.authState.refresh();\n      }\n    });\n  }\n  /**\n   * ```js\n   * getAccessTokenSilently(options).subscribe(token => ...)\n   * ```\n   *\n   * If there's a valid token stored, return it. Otherwise, opens an\n   * iframe with the `/authorize` URL using the parameters provided\n   * as arguments. Random and secure `state` and `nonce` parameters\n   * will be auto-generated. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * If refresh tokens are used, the token endpoint is called directly with the\n   * 'refresh_token' grant. If no refresh token is available to make this call,\n   * the SDK falls back to using an iframe to the '/authorize' URL.\n   *\n   * This method may use a web worker to perform the token call if the in-memory\n   * cache is used.\n   *\n   * If an `audience` value is given to this function, the SDK always falls\n   * back to using an iframe to make the token exchange.\n   *\n   * Note that in all cases, falling back to an iframe requires access to\n   * the `auth0` cookie, and thus will not work in browsers that block third-party\n   * cookies by default (Safari, Brave, etc).\n   *\n   * @param options The options for configuring the token fetch.\n   */\n\n\n  getAccessTokenSilently(options = {}) {\n    return of(this.auth0Client).pipe(concatMap(client => options.detailedResponse === true ? client.getTokenSilently(Object.assign(Object.assign({}, options), {\n      detailedResponse: true\n    })) : client.getTokenSilently(options)), tap(token => this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token)), catchError(error => {\n      this.authState.setError(error);\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * ```js\n   * getTokenWithPopup(options).subscribe(token => ...)\n   * ```\n   *\n   * Get an access token interactively.\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   */\n\n\n  getAccessTokenWithPopup(options) {\n    return of(this.auth0Client).pipe(concatMap(client => client.getTokenWithPopup(options)), tap(token => this.authState.setAccessToken(token)), catchError(error => {\n      this.authState.setError(error);\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * ```js\n   * getUser(options).subscribe(user => ...);\n   * ```\n   *\n   * Returns the user information if available (decoded\n   * from the `id_token`).\n   *\n   * If you provide an audience or scope, they should match an existing Access Token\n   * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n   * scope and audience to look up the ID Token)\n   *\n   * @remarks\n   *\n   * The returned observable will emit once and then complete.\n   *\n   * @typeparam TUser The type to return, has to extend {@link User}.\n   * @param options The options to get the user\n   */\n\n\n  getUser(options) {\n    return defer(() => this.auth0Client.getUser(options));\n  }\n  /**\n   * ```js\n   * getIdTokenClaims(options).subscribe(claims => ...);\n   * ```\n   *\n   * Returns all claims from the id_token if available.\n   *\n   * If you provide an audience or scope, they should match an existing Access Token\n   * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n   * scope and audience to look up the ID Token)\n   *\n   * @remarks\n   *\n   * The returned observable will emit once and then complete.\n   *\n   * @param options The options to get the Id token claims\n   */\n\n\n  getIdTokenClaims(options) {\n    return defer(() => this.auth0Client.getIdTokenClaims(options));\n  }\n  /**\n   * ```js\n   * handleRedirectCallback(url).subscribe(result => ...)\n   * ```\n   *\n   * After the browser redirects back to the callback page,\n   * call `handleRedirectCallback` to handle success and error\n   * responses from Auth0. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * Calling this method also refreshes the authentication and user states.\n   *\n   * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n   */\n\n\n  handleRedirectCallback(url) {\n    return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n      var _a;\n\n      if (!isLoading) {\n        this.authState.refresh();\n      }\n\n      const appState = result === null || result === void 0 ? void 0 : result.appState;\n      const target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';\n\n      if (appState) {\n        this.appStateSubject$.next(appState);\n      }\n\n      this.navigator.navigateByUrl(target);\n    }), map(([result]) => result));\n  }\n  /**\n   * ```js\n   * buildAuthorizeUrl().subscribe(url => ...)\n   * ```\n   *\n   * Builds an `/authorize` URL for loginWithRedirect using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   * @param options The options\n   * @returns A URL to the authorize endpoint\n   */\n\n\n  buildAuthorizeUrl(options) {\n    return defer(() => this.auth0Client.buildAuthorizeUrl(options));\n  }\n  /**\n   * ```js\n   * buildLogoutUrl().subscribe(url => ...)\n   * ```\n   * Builds a URL to the logout endpoint.\n   *\n   * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n   * @returns a URL to the logout endpoint using the parameters provided as arguments.\n   */\n\n\n  buildLogoutUrl(options) {\n    return of(this.auth0Client.buildLogoutUrl(options));\n  }\n\n  shouldHandleCallback() {\n    return of(location.search).pipe(map(search => {\n      return (search.includes('code=') || search.includes('error=')) && search.includes('state=') && !this.configFactory.get().skipRedirectCallback;\n    }));\n  }\n\n}\n\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(AbstractNavigator), ɵngcc0.ɵɵinject(AuthState));\n};\n\nAuthService.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthService_Factory() {\n    return new AuthService(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState));\n  },\n  token: AuthService,\n  providedIn: \"root\"\n});\n\nAuthService.ctorParameters = () => [{\n  type: Auth0Client,\n  decorators: [{\n    type: Inject,\n    args: [Auth0ClientService]\n  }]\n}, {\n  type: AuthClientConfig\n}, {\n  type: AbstractNavigator\n}, {\n  type: AuthState\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthClientConfig\n    }, {\n      type: AbstractNavigator\n    }, {\n      type: AuthState\n    }];\n  }, null);\n})();\n\nclass AuthGuard {\n  constructor(auth) {\n    this.auth = auth;\n  }\n\n  canLoad(route, segments) {\n    return this.auth.isAuthenticated$.pipe(take(1));\n  }\n\n  canActivate(next, state) {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  canActivateChild(childRoute, state) {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  redirectIfUnauthenticated(state) {\n    return this.auth.isAuthenticated$.pipe(tap(loggedIn => {\n      if (!loggedIn) {\n        this.auth.loginWithRedirect({\n          appState: {\n            target: state.url\n          }\n        });\n      }\n    }));\n  }\n\n}\n\nAuthGuard.ɵfac = function AuthGuard_Factory(t) {\n  return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService));\n};\n\nAuthGuard.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthGuard_Factory() {\n    return new AuthGuard(i0.ɵɵinject(AuthService));\n  },\n  token: AuthGuard,\n  providedIn: \"root\"\n});\n\nAuthGuard.ctorParameters = () => [{\n  type: AuthService\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AuthService\n    }];\n  }, null);\n})();\n\nclass AuthModule {\n  /**\n   * Initialize the authentication module system. Configuration can either be specified here,\n   * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n   * @param config The optional configuration for the SDK.\n   */\n  static forRoot(config) {\n    return {\n      ngModule: AuthModule,\n      providers: [AuthService, AuthGuard, {\n        provide: AuthConfigService,\n        useValue: config\n      }, {\n        provide: Auth0ClientService,\n        useFactory: Auth0ClientFactory.createClient,\n        deps: [AuthClientConfig]\n      }]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\nclass AuthHttpInterceptor {\n  constructor(configFactory, auth0Client, authState) {\n    this.configFactory = configFactory;\n    this.auth0Client = auth0Client;\n    this.authState = authState;\n  }\n\n  intercept(req, next) {\n    var _a;\n\n    const config = this.configFactory.get();\n\n    if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {\n      return next.handle(req);\n    }\n\n    return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap(route => iif( // Check if a route was matched\n    () => route !== null, // If we have a matching route, call getTokenSilently and attach the token to the\n    // outgoing request\n    of(route).pipe(pluck('tokenOptions'), concatMap(options => {\n      return this.getAccessTokenSilently(options).pipe(catchError(err => {\n        if (this.allowAnonymous(route, err)) {\n          return of('');\n        }\n\n        this.authState.setError(err);\n        return throwError(err);\n      }));\n    }), switchMap(token => {\n      // Clone the request and attach the bearer token\n      const clone = token ? req.clone({\n        headers: req.headers.set('Authorization', `Bearer ${token}`)\n      }) : req;\n      return next.handle(clone);\n    })), // If the URI being called was not found in our httpInterceptor config, simply\n    // pass the request through without attaching a token\n    next.handle(req))));\n  }\n  /**\n   * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n   * Only used internally in the interceptor.\n   * @param options The options for configuring the token fetch.\n   */\n\n\n  getAccessTokenSilently(options) {\n    return of(this.auth0Client).pipe(concatMap(client => client.getTokenSilently(options)), tap(token => this.authState.setAccessToken(token)), catchError(error => {\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * Strips the query and fragment from the given uri\n   * @param uri The uri to remove the query and fragment from\n   */\n\n\n  stripQueryFrom(uri) {\n    if (uri.indexOf('?') > -1) {\n      uri = uri.substr(0, uri.indexOf('?'));\n    }\n\n    if (uri.indexOf('#') > -1) {\n      uri = uri.substr(0, uri.indexOf('#'));\n    }\n\n    return uri;\n  }\n  /**\n   * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n   * the interceptor route configuration.\n   * @param route The route to test\n   * @param request The HTTP request\n   */\n\n\n  canAttachToken(route, request) {\n    const testPrimitive = value => {\n      if (!value) {\n        return false;\n      }\n\n      const requestPath = this.stripQueryFrom(request.url);\n\n      if (value === requestPath) {\n        return true;\n      } // If the URL ends with an asterisk, match using startsWith.\n\n\n      return value.indexOf('*') === value.length - 1 && request.url.startsWith(value.substr(0, value.length - 1));\n    };\n\n    if (isHttpInterceptorRouteConfig(route)) {\n      if (route.httpMethod && route.httpMethod !== request.method) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (!route.uri && !route.uriMatcher) {\n        console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n      }\n\n      return route.uriMatcher ? route.uriMatcher(request.url) : testPrimitive(route.uri);\n    }\n\n    return testPrimitive(route);\n  }\n  /**\n   * Tries to match a route from the SDK configuration to the HTTP request.\n   * If a match is found, the route configuration is returned.\n   * @param request The Http request\n   * @param config HttpInterceptorConfig\n   */\n\n\n  findMatchingRoute(request, config) {\n    return from(config.allowedList).pipe(first(route => this.canAttachToken(route, request), null));\n  }\n\n  allowAnonymous(route, err) {\n    return !!route && isHttpInterceptorRouteConfig(route) && !!route.allowAnonymous && ['login_required', 'consent_required'].includes(err.error);\n  }\n\n}\n\nAuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) {\n  return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthState));\n};\n\nAuthHttpInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: AuthHttpInterceptor,\n  factory: AuthHttpInterceptor.ɵfac\n});\n\nAuthHttpInterceptor.ctorParameters = () => [{\n  type: AuthClientConfig\n}, {\n  type: Auth0Client,\n  decorators: [{\n    type: Inject,\n    args: [Auth0ClientService]\n  }]\n}, {\n  type: AuthState\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthHttpInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthClientConfig\n    }, {\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthState\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, isHttpInterceptorRouteConfig, AbstractNavigator as ɵa };","map":{"version":3,"names":["i0","VERSION","InjectionToken","Injectable","Injector","Optional","Inject","NgModule","Auth0Client","ɵngcc0","ɵngcc1","ɵngcc2","InMemoryCache","LocalStorageCache","User","BehaviorSubject","Subject","ReplaySubject","merge","defer","of","iif","from","throwError","scan","filter","distinctUntilChanged","switchMap","mergeMap","shareReplay","concatMap","catchError","tap","takeUntil","withLatestFrom","map","take","pluck","first","__rest","Router","i1","Location","useragent","name","version","Auth0ClientFactory","createClient","configFactory","config","get","Error","redirectUri","clientId","maxAge","httpInterceptor","rest","Object","assign","redirect_uri","window","location","origin","client_id","max_age","auth0Client","env","full","Auth0ClientService","AbstractNavigator","constructor","injector","router","_a","navigateByUrl","url","replaceState","ɵfac","AbstractNavigator_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","factory","INJECTOR","token","providedIn","ctorParameters","type","ngDevMode","ɵsetClassMetadata","args","isHttpInterceptorRouteConfig","def","AuthClientConfig","set","AuthClientConfig_Factory","AuthConfigService","undefined","decorators","AuthState","isLoadingSubject$","refresh$","accessToken$","errorSubject$","isLoading$","asObservable","accessTokenTrigger$","pipe","acc","current","previous","isAuthenticatedTrigger$","loading","isAuthenticated","isAuthenticated$","user$","authenticated","getUser","idTokenClaims$","getIdTokenClaims","error$","setIsLoading","isLoading","next","refresh","setAccessToken","accessToken","setError","error","AuthState_Factory","AuthService","navigator","authState","appStateSubject$","ngUnsubscribe$","appState$","checkSessionOrCallback$","isCallback","handleRedirectCallback","checkSession","shouldHandleCallback","errorPath","subscribe","ngOnDestroy","complete","loginWithRedirect","options","loginWithPopup","then","logout","localOnly","getAccessTokenSilently","client","detailedResponse","getTokenSilently","access_token","getAccessTokenWithPopup","getTokenWithPopup","result","appState","target","buildAuthorizeUrl","buildLogoutUrl","search","includes","skipRedirectCallback","AuthService_Factory","AuthGuard","auth","canLoad","route","segments","canActivate","state","redirectIfUnauthenticated","canActivateChild","childRoute","loggedIn","AuthGuard_Factory","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","AuthModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","AuthHttpInterceptor","intercept","req","allowedList","handle","findMatchingRoute","err","allowAnonymous","clone","headers","stripQueryFrom","uri","indexOf","substr","canAttachToken","request","testPrimitive","value","requestPath","length","startsWith","httpMethod","method","uriMatcher","console","warn","AuthHttpInterceptor_Factory","ɵa"],"sources":["/Users/andrewhughes/Desktop/project3/e-commerce-frontend-angular/node_modules/@auth0/auth0-angular/__ivy_ngcc__/fesm2015/auth0-auth0-angular.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { VERSION, InjectionToken, Injectable, Injector, Optional, Inject, NgModule } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@auth0/auth0-spa-js';\nexport { InMemoryCache, LocalStorageCache, User } from '@auth0/auth0-spa-js';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, pluck, first } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { Location } from '@angular/common';\n\nvar useragent = { name: '@auth0/auth0-angular', version: '1.10.1' };\n\nclass Auth0ClientFactory {\n    static createClient(configFactory) {\n        const config = configFactory.get();\n        if (!config) {\n            throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n        }\n        const { redirectUri, clientId, maxAge, httpInterceptor } = config, rest = __rest(config, [\"redirectUri\", \"clientId\", \"maxAge\", \"httpInterceptor\"]);\n        return new Auth0Client(Object.assign(Object.assign({ redirect_uri: redirectUri || window.location.origin, client_id: clientId, max_age: maxAge }, rest), { auth0Client: {\n                name: useragent.name,\n                version: useragent.version,\n                env: {\n                    'angular/core': VERSION.full,\n                },\n            } }));\n    }\n}\nconst Auth0ClientService = new InjectionToken('auth0.client');\n\nclass AbstractNavigator {\n    constructor(location, injector) {\n        this.location = location;\n        try {\n            this.router = injector.get(Router);\n        }\n        catch (_a) { }\n    }\n    /**\n     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n     * to `window.history.replaceState`.\n     * @param url The url to navigate to\n     */\n    navigateByUrl(url) {\n        if (this.router) {\n            this.router.navigateByUrl(url);\n            return;\n        }\n        this.location.replaceState(url);\n    }\n}\nAbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) { return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };\nAbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbstractNavigator_Factory() { return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR)); }, token: AbstractNavigator, providedIn: \"root\" });\nAbstractNavigator.ctorParameters = () => [\n    { type: Location },\n    { type: Injector }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc0.Injector }]; }, null); })();\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\nfunction isHttpInterceptorRouteConfig(def) {\n    return typeof def !== 'string';\n}\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\nclass AuthClientConfig {\n    constructor(config) {\n        if (config) {\n            this.set(config);\n        }\n    }\n    /**\n     * Sets configuration to be read by other consumers of the service (see usage notes)\n     * @param config The configuration to set\n     */\n    set(config) {\n        this.config = config;\n    }\n    /**\n     * Gets the config that has been set by other consumers of the service\n     */\n    get() {\n        return this.config;\n    }\n}\nAuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) { return new (t || AuthClientConfig)(ɵngcc0.ɵɵinject(AuthConfigService, 8)); };\nAuthClientConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthClientConfig_Factory() { return new AuthClientConfig(i0.ɵɵinject(AuthConfigService, 8)); }, token: AuthClientConfig, providedIn: \"root\" });\nAuthClientConfig.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [AuthConfigService,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthClientConfig, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [AuthConfigService]\n            }] }]; }, null); })();\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n\n/**\n * Tracks the Authentication State for the SDK\n */\nclass AuthState {\n    constructor(auth0Client) {\n        this.auth0Client = auth0Client;\n        this.isLoadingSubject$ = new BehaviorSubject(true);\n        this.refresh$ = new Subject();\n        this.accessToken$ = new ReplaySubject(1);\n        this.errorSubject$ = new ReplaySubject(1);\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.isLoadingSubject$.asObservable();\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when the access token has changed.\n         */\n        this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => {\n            return {\n                previous: acc.current,\n                current,\n            };\n        }, { current: null, previous: null }), filter(({ previous, current }) => previous !== current));\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when an event occurs that needs to retrigger the User Profile information.\n         * Events: Login, Access Token change and Logout\n         */\n        this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter((loading) => !loading), distinctUntilChanged(), switchMap(() => \n        // To track the value of isAuthenticated over time, we need to merge:\n        //  - the current value\n        //  - the value whenever the access token changes. (this should always be true of there is an access token\n        //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n        //  - the value whenever refreshState$ emits\n        merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getUser() : of(null)));\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.errorSubject$.asObservable();\n    }\n    /**\n     * Update the isLoading state using the provided value\n     * @param isLoading The new value for isLoading\n     */\n    setIsLoading(isLoading) {\n        this.isLoadingSubject$.next(isLoading);\n    }\n    /**\n     * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n     * reflect the most up-to-date values from  Auth0Client.\n     */\n    refresh() {\n        this.refresh$.next();\n    }\n    /**\n     * Update the access token, doing so will also refresh the state.\n     * @param accessToken The new Access Token\n     */\n    setAccessToken(accessToken) {\n        this.accessToken$.next(accessToken);\n    }\n    /**\n     * Emits the error in the `error$` observable.\n     * @param error The new error\n     */\n    setError(error) {\n        this.errorSubject$.next(error);\n    }\n}\nAuthState.ɵfac = function AuthState_Factory(t) { return new (t || AuthState)(ɵngcc0.ɵɵinject(Auth0ClientService)); };\nAuthState.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthState_Factory() { return new AuthState(i0.ɵɵinject(Auth0ClientService)); }, token: AuthState, providedIn: \"root\" });\nAuthState.ctorParameters = () => [\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthState, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }]; }, null); })();\n\nclass AuthService {\n    constructor(auth0Client, configFactory, navigator, authState) {\n        this.auth0Client = auth0Client;\n        this.configFactory = configFactory;\n        this.navigator = navigator;\n        this.authState = authState;\n        this.appStateSubject$ = new ReplaySubject(1);\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$ = new Subject();\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.authState.isLoading$;\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.authState.isAuthenticated$;\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.authState.user$;\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.authState.idTokenClaims$;\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.authState.error$;\n        /**\n         * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n         * but only **after** `handleRedirectCallback` is first called\n         */\n        this.appState$ = this.appStateSubject$.asObservable();\n        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n        this.shouldHandleCallback()\n            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {\n            const config = this.configFactory.get();\n            this.navigator.navigateByUrl(config.errorPath || '/');\n            this.authState.setError(error);\n            return of(undefined);\n        }))), tap(() => {\n            this.authState.setIsLoading(false);\n        }), takeUntil(this.ngUnsubscribe$))\n            .subscribe();\n    }\n    /**\n     * Called when the service is destroyed\n     */\n    ngOnDestroy() {\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$.next();\n        this.ngUnsubscribe$.complete();\n    }\n    /**\n     * ```js\n     * loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to `/authorize` using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     *\n     * @param options The login options\n     */\n    loginWithRedirect(options) {\n        return from(this.auth0Client.loginWithRedirect(options));\n    }\n    /**\n     * ```js\n     * await loginWithPopup(options);\n     * ```\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     *\n     * IMPORTANT: This method has to be called from an event handler\n     * that was started by the user like a button click, for example,\n     * otherwise the popup will be blocked in most browsers.\n     *\n     * @param options The login options\n     * @param config Configuration for the popup window\n     */\n    loginWithPopup(options, config) {\n        return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n            this.authState.refresh();\n        }));\n    }\n    /**\n     * ```js\n     * logout();\n     * ```\n     *\n     * Clears the application session and performs a redirect to `/v2/logout`, using\n     * the parameters provided as arguments, to clear the Auth0 session.\n     * If the `federated` option is specified it also clears the Identity Provider session.\n     * If the `localOnly` option is specified, it only clears the application session.\n     * It is invalid to set both the `federated` and `localOnly` options to `true`,\n     * and an error will be thrown if you do.\n     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n     *\n     * @param options The logout options\n     */\n    logout(options) {\n        const logout = this.auth0Client.logout(options) || of(null);\n        from(logout).subscribe(() => {\n            if (options === null || options === void 0 ? void 0 : options.localOnly) {\n                this.authState.refresh();\n            }\n        });\n    }\n    /**\n     * ```js\n     * getAccessTokenSilently(options).subscribe(token => ...)\n     * ```\n     *\n     * If there's a valid token stored, return it. Otherwise, opens an\n     * iframe with the `/authorize` URL using the parameters provided\n     * as arguments. Random and secure `state` and `nonce` parameters\n     * will be auto-generated. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * If refresh tokens are used, the token endpoint is called directly with the\n     * 'refresh_token' grant. If no refresh token is available to make this call,\n     * the SDK falls back to using an iframe to the '/authorize' URL.\n     *\n     * This method may use a web worker to perform the token call if the in-memory\n     * cache is used.\n     *\n     * If an `audience` value is given to this function, the SDK always falls\n     * back to using an iframe to make the token exchange.\n     *\n     * Note that in all cases, falling back to an iframe requires access to\n     * the `auth0` cookie, and thus will not work in browsers that block third-party\n     * cookies by default (Safari, Brave, etc).\n     *\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options = {}) {\n        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true\n            ? client.getTokenSilently(Object.assign(Object.assign({}, options), { detailedResponse: true }))\n            : client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token)), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * getTokenWithPopup(options).subscribe(token => ...)\n     * ```\n     *\n     * Get an access token interactively.\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     */\n    getAccessTokenWithPopup(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * getUser(options).subscribe(user => ...);\n     * ```\n     *\n     * Returns the user information if available (decoded\n     * from the `id_token`).\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @typeparam TUser The type to return, has to extend {@link User}.\n     * @param options The options to get the user\n     */\n    getUser(options) {\n        return defer(() => this.auth0Client.getUser(options));\n    }\n    /**\n     * ```js\n     * getIdTokenClaims(options).subscribe(claims => ...);\n     * ```\n     *\n     * Returns all claims from the id_token if available.\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @param options The options to get the Id token claims\n     */\n    getIdTokenClaims(options) {\n        return defer(() => this.auth0Client.getIdTokenClaims(options));\n    }\n    /**\n     * ```js\n     * handleRedirectCallback(url).subscribe(result => ...)\n     * ```\n     *\n     * After the browser redirects back to the callback page,\n     * call `handleRedirectCallback` to handle success and error\n     * responses from Auth0. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * Calling this method also refreshes the authentication and user states.\n     *\n     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n     */\n    handleRedirectCallback(url) {\n        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n            var _a;\n            if (!isLoading) {\n                this.authState.refresh();\n            }\n            const appState = result === null || result === void 0 ? void 0 : result.appState;\n            const target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';\n            if (appState) {\n                this.appStateSubject$.next(appState);\n            }\n            this.navigator.navigateByUrl(target);\n        }), map(([result]) => result));\n    }\n    /**\n     * ```js\n     * buildAuthorizeUrl().subscribe(url => ...)\n     * ```\n     *\n     * Builds an `/authorize` URL for loginWithRedirect using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     * @param options The options\n     * @returns A URL to the authorize endpoint\n     */\n    buildAuthorizeUrl(options) {\n        return defer(() => this.auth0Client.buildAuthorizeUrl(options));\n    }\n    /**\n     * ```js\n     * buildLogoutUrl().subscribe(url => ...)\n     * ```\n     * Builds a URL to the logout endpoint.\n     *\n     * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n     * @returns a URL to the logout endpoint using the parameters provided as arguments.\n     */\n    buildLogoutUrl(options) {\n        return of(this.auth0Client.buildLogoutUrl(options));\n    }\n    shouldHandleCallback() {\n        return of(location.search).pipe(map((search) => {\n            return ((search.includes('code=') || search.includes('error=')) &&\n                search.includes('state=') &&\n                !this.configFactory.get().skipRedirectCallback);\n        }));\n    }\n}\nAuthService.ɵfac = function AuthService_Factory(t) { return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(AbstractNavigator), ɵngcc0.ɵɵinject(AuthState)); };\nAuthService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState)); }, token: AuthService, providedIn: \"root\" });\nAuthService.ctorParameters = () => [\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },\n    { type: AuthClientConfig },\n    { type: AbstractNavigator },\n    { type: AuthState }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }, { type: AuthClientConfig }, { type: AbstractNavigator }, { type: AuthState }]; }, null); })();\n\nclass AuthGuard {\n    constructor(auth) {\n        this.auth = auth;\n    }\n    canLoad(route, segments) {\n        return this.auth.isAuthenticated$.pipe(take(1));\n    }\n    canActivate(next, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    redirectIfUnauthenticated(state) {\n        return this.auth.isAuthenticated$.pipe(tap((loggedIn) => {\n            if (!loggedIn) {\n                this.auth.loginWithRedirect({\n                    appState: { target: state.url },\n                });\n            }\n        }));\n    }\n}\nAuthGuard.ɵfac = function AuthGuard_Factory(t) { return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService)); };\nAuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(AuthService)); }, token: AuthGuard, providedIn: \"root\" });\nAuthGuard.ctorParameters = () => [\n    { type: AuthService }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: AuthService }]; }, null); })();\n\nclass AuthModule {\n    /**\n     * Initialize the authentication module system. Configuration can either be specified here,\n     * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n     * @param config The optional configuration for the SDK.\n     */\n    static forRoot(config) {\n        return {\n            ngModule: AuthModule,\n            providers: [\n                AuthService,\n                AuthGuard,\n                {\n                    provide: AuthConfigService,\n                    useValue: config,\n                },\n                {\n                    provide: Auth0ClientService,\n                    useFactory: Auth0ClientFactory.createClient,\n                    deps: [AuthClientConfig],\n                },\n            ],\n        };\n    }\n}\nAuthModule.ɵfac = function AuthModule_Factory(t) { return new (t || AuthModule)(); };\nAuthModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: AuthModule });\nAuthModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthModule, [{\n        type: NgModule\n    }], null, null); })();\n\nclass AuthHttpInterceptor {\n    constructor(configFactory, auth0Client, authState) {\n        this.configFactory = configFactory;\n        this.auth0Client = auth0Client;\n        this.authState = authState;\n    }\n    intercept(req, next) {\n        var _a;\n        const config = this.configFactory.get();\n        if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {\n            return next.handle(req);\n        }\n        return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap((route) => iif(\n        // Check if a route was matched\n        () => route !== null, \n        // If we have a matching route, call getTokenSilently and attach the token to the\n        // outgoing request\n        of(route).pipe(pluck('tokenOptions'), concatMap((options) => {\n            return this.getAccessTokenSilently(options).pipe(catchError((err) => {\n                if (this.allowAnonymous(route, err)) {\n                    return of('');\n                }\n                this.authState.setError(err);\n                return throwError(err);\n            }));\n        }), switchMap((token) => {\n            // Clone the request and attach the bearer token\n            const clone = token\n                ? req.clone({\n                    headers: req.headers.set('Authorization', `Bearer ${token}`),\n                })\n                : req;\n            return next.handle(clone);\n        })), \n        // If the URI being called was not found in our httpInterceptor config, simply\n        // pass the request through without attaching a token\n        next.handle(req))));\n    }\n    /**\n     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n     * Only used internally in the interceptor.\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * Strips the query and fragment from the given uri\n     * @param uri The uri to remove the query and fragment from\n     */\n    stripQueryFrom(uri) {\n        if (uri.indexOf('?') > -1) {\n            uri = uri.substr(0, uri.indexOf('?'));\n        }\n        if (uri.indexOf('#') > -1) {\n            uri = uri.substr(0, uri.indexOf('#'));\n        }\n        return uri;\n    }\n    /**\n     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n     * the interceptor route configuration.\n     * @param route The route to test\n     * @param request The HTTP request\n     */\n    canAttachToken(route, request) {\n        const testPrimitive = (value) => {\n            if (!value) {\n                return false;\n            }\n            const requestPath = this.stripQueryFrom(request.url);\n            if (value === requestPath) {\n                return true;\n            }\n            // If the URL ends with an asterisk, match using startsWith.\n            return (value.indexOf('*') === value.length - 1 &&\n                request.url.startsWith(value.substr(0, value.length - 1)));\n        };\n        if (isHttpInterceptorRouteConfig(route)) {\n            if (route.httpMethod && route.httpMethod !== request.method) {\n                return false;\n            }\n            /* istanbul ignore if */\n            if (!route.uri && !route.uriMatcher) {\n                console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n            }\n            return route.uriMatcher\n                ? route.uriMatcher(request.url)\n                : testPrimitive(route.uri);\n        }\n        return testPrimitive(route);\n    }\n    /**\n     * Tries to match a route from the SDK configuration to the HTTP request.\n     * If a match is found, the route configuration is returned.\n     * @param request The Http request\n     * @param config HttpInterceptorConfig\n     */\n    findMatchingRoute(request, config) {\n        return from(config.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));\n    }\n    allowAnonymous(route, err) {\n        return (!!route &&\n            isHttpInterceptorRouteConfig(route) &&\n            !!route.allowAnonymous &&\n            ['login_required', 'consent_required'].includes(err.error));\n    }\n}\nAuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) { return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthState)); };\nAuthHttpInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: AuthHttpInterceptor, factory: AuthHttpInterceptor.ɵfac });\nAuthHttpInterceptor.ctorParameters = () => [\n    { type: AuthClientConfig },\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },\n    { type: AuthState }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthHttpInterceptor, [{\n        type: Injectable\n    }], function () { return [{ type: AuthClientConfig }, { type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }, { type: AuthState }]; }, null); })();\n\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, isHttpInterceptorRouteConfig, AbstractNavigator as ɵa };\n\n"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,eAApB;AACA,SAASC,OAAT,EAAkBC,cAAlB,EAAkCC,UAAlC,EAA8CC,QAA9C,EAAwDC,QAAxD,EAAkEC,MAAlE,EAA0EC,QAA1E,QAA0F,eAA1F;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,OAAO,KAAKC,MAAZ,MAAwB,eAAxB;AACA,OAAO,KAAKC,MAAZ,MAAwB,iBAAxB;AACA,OAAO,KAAKC,MAAZ,MAAwB,qBAAxB;AACA,SAASC,aAAT,EAAwBC,iBAAxB,EAA2CC,IAA3C,QAAuD,qBAAvD;AACA,SAASC,eAAT,EAA0BC,OAA1B,EAAmCC,aAAnC,EAAkDC,KAAlD,EAAyDC,KAAzD,EAAgEC,EAAhE,EAAoEC,GAApE,EAAyEC,IAAzE,EAA+EC,UAA/E,QAAiG,MAAjG;AACA,SAASC,IAAT,EAAeC,MAAf,EAAuBC,oBAAvB,EAA6CC,SAA7C,EAAwDC,QAAxD,EAAkEC,WAAlE,EAA+EC,SAA/E,EAA0FC,UAA1F,EAAsGC,GAAtG,EAA2GC,SAA3G,EAAsHC,cAAtH,EAAsIC,GAAtI,EAA2IC,IAA3I,EAAiJC,KAAjJ,EAAwJC,KAAxJ,QAAqK,gBAArK;AACA,SAASC,MAAT,QAAuB,OAAvB;AACA,SAASC,MAAT,QAAuB,iBAAvB;AACA,OAAO,KAAKC,EAAZ,MAAoB,iBAApB;AACA,SAASC,QAAT,QAAyB,iBAAzB;AAEA,IAAIC,SAAS,GAAG;EAAEC,IAAI,EAAE,sBAAR;EAAgCC,OAAO,EAAE;AAAzC,CAAhB;;AAEA,MAAMC,kBAAN,CAAyB;EACF,OAAZC,YAAY,CAACC,aAAD,EAAgB;IAC/B,MAAMC,MAAM,GAAGD,aAAa,CAACE,GAAd,EAAf;;IACA,IAAI,CAACD,MAAL,EAAa;MACT,MAAM,IAAIE,KAAJ,CAAU,mGAAV,CAAN;IACH;;IACD,MAAM;MAAEC,WAAF;MAAeC,QAAf;MAAyBC,MAAzB;MAAiCC;IAAjC,IAAqDN,MAA3D;IAAA,MAAmEO,IAAI,GAAGjB,MAAM,CAACU,MAAD,EAAS,CAAC,aAAD,EAAgB,UAAhB,EAA4B,QAA5B,EAAsC,iBAAtC,CAAT,CAAhF;;IACA,OAAO,IAAIzC,WAAJ,CAAgBiD,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc;MAAEC,YAAY,EAAEP,WAAW,IAAIQ,MAAM,CAACC,QAAP,CAAgBC,MAA/C;MAAuDC,SAAS,EAAEV,QAAlE;MAA4EW,OAAO,EAAEV;IAArF,CAAd,EAA6GE,IAA7G,CAAd,EAAkI;MAAES,WAAW,EAAE;QAChKrB,IAAI,EAAED,SAAS,CAACC,IADgJ;QAEhKC,OAAO,EAAEF,SAAS,CAACE,OAF6I;QAGhKqB,GAAG,EAAE;UACD,gBAAgBjE,OAAO,CAACkE;QADvB;MAH2J;IAAf,CAAlI,CAAhB,CAAP;EAOH;;AAdoB;;AAgBzB,MAAMC,kBAAkB,GAAG,IAAIlE,cAAJ,CAAmB,cAAnB,CAA3B;;AAEA,MAAMmE,iBAAN,CAAwB;EACpBC,WAAW,CAACT,QAAD,EAAWU,QAAX,EAAqB;IAC5B,KAAKV,QAAL,GAAgBA,QAAhB;;IACA,IAAI;MACA,KAAKW,MAAL,GAAcD,QAAQ,CAACrB,GAAT,CAAaV,MAAb,CAAd;IACH,CAFD,CAGA,OAAOiC,EAAP,EAAW,CAAG;EACjB;EACD;AACJ;AACA;AACA;AACA;;;EACIC,aAAa,CAACC,GAAD,EAAM;IACf,IAAI,KAAKH,MAAT,EAAiB;MACb,KAAKA,MAAL,CAAYE,aAAZ,CAA0BC,GAA1B;MACA;IACH;;IACD,KAAKd,QAAL,CAAce,YAAd,CAA2BD,GAA3B;EACH;;AAnBmB;;AAqBxBN,iBAAiB,CAACQ,IAAlB,GAAyB,SAASC,yBAAT,CAAmCC,CAAnC,EAAsC;EAAE,OAAO,KAAKA,CAAC,IAAIV,iBAAV,EAA6B5D,MAAM,CAACuE,QAAP,CAAgBtE,MAAM,CAACgC,QAAvB,CAA7B,EAA+DjC,MAAM,CAACuE,QAAP,CAAgBvE,MAAM,CAACL,QAAvB,CAA/D,CAAP;AAA0G,CAA3K;;AACAiE,iBAAiB,CAACY,KAAlB,GAA0BjF,EAAE,CAACkF,kBAAH,CAAsB;EAAEC,OAAO,EAAE,SAASL,yBAAT,GAAqC;IAAE,OAAO,IAAIT,iBAAJ,CAAsBrE,EAAE,CAACgF,QAAH,CAAYvC,EAAE,CAACC,QAAf,CAAtB,EAAgD1C,EAAE,CAACgF,QAAH,CAAYhF,EAAE,CAACoF,QAAf,CAAhD,CAAP;EAAmF,CAArI;EAAuIC,KAAK,EAAEhB,iBAA9I;EAAiKiB,UAAU,EAAE;AAA7K,CAAtB,CAA1B;;AACAjB,iBAAiB,CAACkB,cAAlB,GAAmC,MAAM,CACrC;EAAEC,IAAI,EAAE9C;AAAR,CADqC,EAErC;EAAE8C,IAAI,EAAEpF;AAAR,CAFqC,CAAzC;;AAIA,CAAC,YAAY;EAAE,CAAC,OAAOqF,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyBrB,iBAAzB,EAA4C,CAAC;IACvGmB,IAAI,EAAErF,UADiG;IAEvGwF,IAAI,EAAE,CAAC;MACCL,UAAU,EAAE;IADb,CAAD;EAFiG,CAAD,CAA5C,EAK1D,YAAY;IAAE,OAAO,CAAC;MAAEE,IAAI,EAAE9E,MAAM,CAACgC;IAAf,CAAD,EAA4B;MAAE8C,IAAI,EAAE/E,MAAM,CAACL;IAAf,CAA5B,CAAP;EAAgE,CALpB,EAKsB,IALtB,CAAnD;AAKiF,CALhG;AAOA;AACA;AACA;AACA;;;AACA,SAASwF,4BAAT,CAAsCC,GAAtC,EAA2C;EACvC,OAAO,OAAOA,GAAP,KAAe,QAAtB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,gBAAN,CAAuB;EACnBxB,WAAW,CAACrB,MAAD,EAAS;IAChB,IAAIA,MAAJ,EAAY;MACR,KAAK8C,GAAL,CAAS9C,MAAT;IACH;EACJ;EACD;AACJ;AACA;AACA;;;EACI8C,GAAG,CAAC9C,MAAD,EAAS;IACR,KAAKA,MAAL,GAAcA,MAAd;EACH;EACD;AACJ;AACA;;;EACIC,GAAG,GAAG;IACF,OAAO,KAAKD,MAAZ;EACH;;AAlBkB;;AAoBvB6C,gBAAgB,CAACjB,IAAjB,GAAwB,SAASmB,wBAAT,CAAkCjB,CAAlC,EAAqC;EAAE,OAAO,KAAKA,CAAC,IAAIe,gBAAV,EAA4BrF,MAAM,CAACuE,QAAP,CAAgBiB,iBAAhB,EAAmC,CAAnC,CAA5B,CAAP;AAA4E,CAA3I;;AACAH,gBAAgB,CAACb,KAAjB,GAAyBjF,EAAE,CAACkF,kBAAH,CAAsB;EAAEC,OAAO,EAAE,SAASa,wBAAT,GAAoC;IAAE,OAAO,IAAIF,gBAAJ,CAAqB9F,EAAE,CAACgF,QAAH,CAAYiB,iBAAZ,EAA+B,CAA/B,CAArB,CAAP;EAAiE,CAAlH;EAAoHZ,KAAK,EAAES,gBAA3H;EAA6IR,UAAU,EAAE;AAAzJ,CAAtB,CAAzB;;AACAQ,gBAAgB,CAACP,cAAjB,GAAkC,MAAM,CACpC;EAAEC,IAAI,EAAEU,SAAR;EAAmBC,UAAU,EAAE,CAAC;IAAEX,IAAI,EAAEnF;EAAR,CAAD,EAAqB;IAAEmF,IAAI,EAAElF,MAAR;IAAgBqF,IAAI,EAAE,CAACM,iBAAD;EAAtB,CAArB;AAA/B,CADoC,CAAxC;;AAGA,CAAC,YAAY;EAAE,CAAC,OAAOR,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyBI,gBAAzB,EAA2C,CAAC;IACtGN,IAAI,EAAErF,UADgG;IAEtGwF,IAAI,EAAE,CAAC;MAAEL,UAAU,EAAE;IAAd,CAAD;EAFgG,CAAD,CAA3C,EAG1D,YAAY;IAAE,OAAO,CAAC;MAAEE,IAAI,EAAEU,SAAR;MAAmBC,UAAU,EAAE,CAAC;QAC9CX,IAAI,EAAEnF;MADwC,CAAD,EAE9C;QACCmF,IAAI,EAAElF,MADP;QAECqF,IAAI,EAAE,CAACM,iBAAD;MAFP,CAF8C;IAA/B,CAAD,CAAP;EAKF,CAR8C,EAQ5C,IAR4C,CAAnD;AAQe,CAR9B;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMA,iBAAiB,GAAG,IAAI/F,cAAJ,CAAmB,sBAAnB,CAA1B;AAEA;AACA;AACA;;AACA,MAAMkG,SAAN,CAAgB;EACZ9B,WAAW,CAACL,WAAD,EAAc;IACrB,KAAKA,WAAL,GAAmBA,WAAnB;IACA,KAAKoC,iBAAL,GAAyB,IAAItF,eAAJ,CAAoB,IAApB,CAAzB;IACA,KAAKuF,QAAL,GAAgB,IAAItF,OAAJ,EAAhB;IACA,KAAKuF,YAAL,GAAoB,IAAItF,aAAJ,CAAkB,CAAlB,CAApB;IACA,KAAKuF,aAAL,GAAqB,IAAIvF,aAAJ,CAAkB,CAAlB,CAArB;IACA;AACR;AACA;;IACQ,KAAKwF,UAAL,GAAkB,KAAKJ,iBAAL,CAAuBK,YAAvB,EAAlB;IACA;AACR;AACA;AACA;;IACQ,KAAKC,mBAAL,GAA2B,KAAKJ,YAAL,CAAkBK,IAAlB,CAAuBpF,IAAI,CAAC,CAACqF,GAAD,EAAMC,OAAN,KAAkB;MACrE,OAAO;QACHC,QAAQ,EAAEF,GAAG,CAACC,OADX;QAEHA;MAFG,CAAP;IAIH,CALqD,EAKnD;MAAEA,OAAO,EAAE,IAAX;MAAiBC,QAAQ,EAAE;IAA3B,CALmD,CAA3B,EAKYtF,MAAM,CAAC,CAAC;MAAEsF,QAAF;MAAYD;IAAZ,CAAD,KAA2BC,QAAQ,KAAKD,OAAzC,CALlB,CAA3B;IAMA;AACR;AACA;AACA;AACA;;IACQ,KAAKE,uBAAL,GAA+B,KAAKP,UAAL,CAAgBG,IAAhB,CAAqBnF,MAAM,CAAEwF,OAAD,IAAa,CAACA,OAAf,CAA3B,EAAoDvF,oBAAoB,EAAxE,EAA4EC,SAAS,CAAC,MACrH;IACA;IACA;IACA;IACA;IACAT,KAAK,CAACC,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiBiD,eAAjB,EAAP,CAAN,EAAkD,KAAKP,mBAAL,CAAyBC,IAAzB,CAA8BhF,QAAQ,CAAC,MAAM,KAAKqC,WAAL,CAAiBiD,eAAjB,EAAP,CAAtC,CAAlD,EAAqI,KAAKZ,QAAL,CAAcM,IAAd,CAAmBhF,QAAQ,CAAC,MAAM,KAAKqC,WAAL,CAAiBiD,eAAjB,EAAP,CAA3B,CAArI,CAN+G,CAArF,CAA/B;IAOA;AACR;AACA;AACA;;IACQ,KAAKC,gBAAL,GAAwB,KAAKH,uBAAL,CAA6BJ,IAA7B,CAAkClF,oBAAoB,EAAtD,EAA0DG,WAAW,CAAC,CAAD,CAArE,CAAxB;IACA;AACR;AACA;;IACQ,KAAKuF,KAAL,GAAa,KAAKJ,uBAAL,CAA6BJ,IAA7B,CAAkC9E,SAAS,CAAEuF,aAAD,IAAmBA,aAAa,GAAG,KAAKpD,WAAL,CAAiBqD,OAAjB,EAAH,GAAgClG,EAAE,CAAC,IAAD,CAAnE,CAA3C,CAAb;IACA;AACR;AACA;;IACQ,KAAKmG,cAAL,GAAsB,KAAKP,uBAAL,CAA6BJ,IAA7B,CAAkC9E,SAAS,CAAEuF,aAAD,IAAmBA,aAAa,GAAG,KAAKpD,WAAL,CAAiBuD,gBAAjB,EAAH,GAAyCpG,EAAE,CAAC,IAAD,CAA5E,CAA3C,CAAtB;IACA;AACR;AACA;;IACQ,KAAKqG,MAAL,GAAc,KAAKjB,aAAL,CAAmBE,YAAnB,EAAd;EACH;EACD;AACJ;AACA;AACA;;;EACIgB,YAAY,CAACC,SAAD,EAAY;IACpB,KAAKtB,iBAAL,CAAuBuB,IAAvB,CAA4BD,SAA5B;EACH;EACD;AACJ;AACA;AACA;;;EACIE,OAAO,GAAG;IACN,KAAKvB,QAAL,CAAcsB,IAAd;EACH;EACD;AACJ;AACA;AACA;;;EACIE,cAAc,CAACC,WAAD,EAAc;IACxB,KAAKxB,YAAL,CAAkBqB,IAAlB,CAAuBG,WAAvB;EACH;EACD;AACJ;AACA;AACA;;;EACIC,QAAQ,CAACC,KAAD,EAAQ;IACZ,KAAKzB,aAAL,CAAmBoB,IAAnB,CAAwBK,KAAxB;EACH;;AA9EW;;AAgFhB7B,SAAS,CAACvB,IAAV,GAAiB,SAASqD,iBAAT,CAA2BnD,CAA3B,EAA8B;EAAE,OAAO,KAAKA,CAAC,IAAIqB,SAAV,EAAqB3F,MAAM,CAACuE,QAAP,CAAgBZ,kBAAhB,CAArB,CAAP;AAAmE,CAApH;;AACAgC,SAAS,CAACnB,KAAV,GAAkBjF,EAAE,CAACkF,kBAAH,CAAsB;EAAEC,OAAO,EAAE,SAAS+C,iBAAT,GAA6B;IAAE,OAAO,IAAI9B,SAAJ,CAAcpG,EAAE,CAACgF,QAAH,CAAYZ,kBAAZ,CAAd,CAAP;EAAwD,CAAlG;EAAoGiB,KAAK,EAAEe,SAA3G;EAAsHd,UAAU,EAAE;AAAlI,CAAtB,CAAlB;;AACAc,SAAS,CAACb,cAAV,GAA2B,MAAM,CAC7B;EAAEC,IAAI,EAAEhF,WAAR;EAAqB2F,UAAU,EAAE,CAAC;IAAEX,IAAI,EAAElF,MAAR;IAAgBqF,IAAI,EAAE,CAACvB,kBAAD;EAAtB,CAAD;AAAjC,CAD6B,CAAjC;;AAGA,CAAC,YAAY;EAAE,CAAC,OAAOqB,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyBU,SAAzB,EAAoC,CAAC;IAC/FZ,IAAI,EAAErF,UADyF;IAE/FwF,IAAI,EAAE,CAAC;MAAEL,UAAU,EAAE;IAAd,CAAD;EAFyF,CAAD,CAApC,EAG1D,YAAY;IAAE,OAAO,CAAC;MAAEE,IAAI,EAAE7E,MAAM,CAACH,WAAf;MAA4B2F,UAAU,EAAE,CAAC;QACvDX,IAAI,EAAElF,MADiD;QAEvDqF,IAAI,EAAE,CAACvB,kBAAD;MAFiD,CAAD;IAAxC,CAAD,CAAP;EAGF,CAN8C,EAM5C,IAN4C,CAAnD;AAMe,CAN9B;;AAQA,MAAM+D,WAAN,CAAkB;EACd7D,WAAW,CAACL,WAAD,EAAcjB,aAAd,EAA6BoF,SAA7B,EAAwCC,SAAxC,EAAmD;IAC1D,KAAKpE,WAAL,GAAmBA,WAAnB;IACA,KAAKjB,aAAL,GAAqBA,aAArB;IACA,KAAKoF,SAAL,GAAiBA,SAAjB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKC,gBAAL,GAAwB,IAAIrH,aAAJ,CAAkB,CAAlB,CAAxB,CAL0D,CAM1D;;IACA,KAAKsH,cAAL,GAAsB,IAAIvH,OAAJ,EAAtB;IACA;AACR;AACA;;IACQ,KAAKyF,UAAL,GAAkB,KAAK4B,SAAL,CAAe5B,UAAjC;IACA;AACR;AACA;AACA;;IACQ,KAAKU,gBAAL,GAAwB,KAAKkB,SAAL,CAAelB,gBAAvC;IACA;AACR;AACA;;IACQ,KAAKC,KAAL,GAAa,KAAKiB,SAAL,CAAejB,KAA5B;IACA;AACR;AACA;;IACQ,KAAKG,cAAL,GAAsB,KAAKc,SAAL,CAAed,cAArC;IACA;AACR;AACA;;IACQ,KAAKE,MAAL,GAAc,KAAKY,SAAL,CAAeZ,MAA7B;IACA;AACR;AACA;AACA;;IACQ,KAAKe,SAAL,GAAiB,KAAKF,gBAAL,CAAsB5B,YAAtB,EAAjB;;IACA,MAAM+B,uBAAuB,GAAIC,UAAD,IAAgBrH,GAAG,CAAC,MAAMqH,UAAP,EAAmB,KAAKC,sBAAL,EAAnB,EAAkDxH,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiB2E,YAAjB,EAAP,CAAvD,CAAnD;;IACA,KAAKC,oBAAL,GACKjC,IADL,CACUjF,SAAS,CAAE+G,UAAD,IAAgBD,uBAAuB,CAACC,UAAD,CAAvB,CAAoC9B,IAApC,CAAyC7E,UAAU,CAAEkG,KAAD,IAAW;MAC/F,MAAMhF,MAAM,GAAG,KAAKD,aAAL,CAAmBE,GAAnB,EAAf;MACA,KAAKkF,SAAL,CAAe1D,aAAf,CAA6BzB,MAAM,CAAC6F,SAAP,IAAoB,GAAjD;MACA,KAAKT,SAAL,CAAeL,QAAf,CAAwBC,KAAxB;MACA,OAAO7G,EAAE,CAAC8E,SAAD,CAAT;IACH,CALsF,CAAnD,CAAjB,CADnB,EAMMlE,GAAG,CAAC,MAAM;MACZ,KAAKqG,SAAL,CAAeX,YAAf,CAA4B,KAA5B;IACH,CAFQ,CANT,EAQIzF,SAAS,CAAC,KAAKsG,cAAN,CARb,EASKQ,SATL;EAUH;EACD;AACJ;AACA;;;EACIC,WAAW,GAAG;IACV;IACA,KAAKT,cAAL,CAAoBX,IAApB;IACA,KAAKW,cAAL,CAAoBU,QAApB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,iBAAiB,CAACC,OAAD,EAAU;IACvB,OAAO7H,IAAI,CAAC,KAAK2C,WAAL,CAAiBiF,iBAAjB,CAAmCC,OAAnC,CAAD,CAAX;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,cAAc,CAACD,OAAD,EAAUlG,MAAV,EAAkB;IAC5B,OAAO3B,IAAI,CAAC,KAAK2C,WAAL,CAAiBmF,cAAjB,CAAgCD,OAAhC,EAAyClG,MAAzC,EAAiDoG,IAAjD,CAAsD,MAAM;MACpE,KAAKhB,SAAL,CAAeR,OAAf;IACH,CAFW,CAAD,CAAX;EAGH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIyB,MAAM,CAACH,OAAD,EAAU;IACZ,MAAMG,MAAM,GAAG,KAAKrF,WAAL,CAAiBqF,MAAjB,CAAwBH,OAAxB,KAAoC/H,EAAE,CAAC,IAAD,CAArD;IACAE,IAAI,CAACgI,MAAD,CAAJ,CAAaP,SAAb,CAAuB,MAAM;MACzB,IAAII,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACI,SAA9D,EAAyE;QACrE,KAAKlB,SAAL,CAAeR,OAAf;MACH;IACJ,CAJD;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI2B,sBAAsB,CAACL,OAAO,GAAG,EAAX,EAAe;IACjC,OAAO/H,EAAE,CAAC,KAAK6C,WAAN,CAAF,CAAqB2C,IAArB,CAA0B9E,SAAS,CAAE2H,MAAD,IAAYN,OAAO,CAACO,gBAAR,KAA6B,IAA7B,GACjDD,MAAM,CAACE,gBAAP,CAAwBlG,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkByF,OAAlB,CAAd,EAA0C;MAAEO,gBAAgB,EAAE;IAApB,CAA1C,CAAxB,CADiD,GAEjDD,MAAM,CAACE,gBAAP,CAAwBR,OAAxB,CAFoC,CAAnC,EAEkCnH,GAAG,CAAEqD,KAAD,IAAW,KAAKgD,SAAL,CAAeP,cAAf,CAA8B,OAAOzC,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAACuE,YAAxE,CAAZ,CAFrC,EAEyI7H,UAAU,CAAEkG,KAAD,IAAW;MAClK,KAAKI,SAAL,CAAeL,QAAf,CAAwBC,KAAxB;MACA,KAAKI,SAAL,CAAeR,OAAf;MACA,OAAOtG,UAAU,CAAC0G,KAAD,CAAjB;IACH,CAJyJ,CAFnJ,CAAP;EAOH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI4B,uBAAuB,CAACV,OAAD,EAAU;IAC7B,OAAO/H,EAAE,CAAC,KAAK6C,WAAN,CAAF,CAAqB2C,IAArB,CAA0B9E,SAAS,CAAE2H,MAAD,IAAYA,MAAM,CAACK,iBAAP,CAAyBX,OAAzB,CAAb,CAAnC,EAAoFnH,GAAG,CAAEqD,KAAD,IAAW,KAAKgD,SAAL,CAAeP,cAAf,CAA8BzC,KAA9B,CAAZ,CAAvF,EAA0ItD,UAAU,CAAEkG,KAAD,IAAW;MACnK,KAAKI,SAAL,CAAeL,QAAf,CAAwBC,KAAxB;MACA,KAAKI,SAAL,CAAeR,OAAf;MACA,OAAOtG,UAAU,CAAC0G,KAAD,CAAjB;IACH,CAJ0J,CAApJ,CAAP;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIX,OAAO,CAAC6B,OAAD,EAAU;IACb,OAAOhI,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiBqD,OAAjB,CAAyB6B,OAAzB,CAAP,CAAZ;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI3B,gBAAgB,CAAC2B,OAAD,EAAU;IACtB,OAAOhI,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiBuD,gBAAjB,CAAkC2B,OAAlC,CAAP,CAAZ;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIR,sBAAsB,CAAChE,GAAD,EAAM;IACxB,OAAOxD,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiB0E,sBAAjB,CAAwChE,GAAxC,CAAP,CAAL,CAA0DiC,IAA1D,CAA+D1E,cAAc,CAAC,KAAKmG,SAAL,CAAe5B,UAAhB,CAA7E,EAA0GzE,GAAG,CAAC,CAAC,CAAC+H,MAAD,EAASpC,SAAT,CAAD,KAAyB;MAC1I,IAAIlD,EAAJ;;MACA,IAAI,CAACkD,SAAL,EAAgB;QACZ,KAAKU,SAAL,CAAeR,OAAf;MACH;;MACD,MAAMmC,QAAQ,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACC,QAAxE;MACA,MAAMC,MAAM,GAAG,CAACxF,EAAE,GAAGuF,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACC,MAAnE,MAA+E,IAA/E,IAAuFxF,EAAE,KAAK,KAAK,CAAnG,GAAuGA,EAAvG,GAA4G,GAA3H;;MACA,IAAIuF,QAAJ,EAAc;QACV,KAAK1B,gBAAL,CAAsBV,IAAtB,CAA2BoC,QAA3B;MACH;;MACD,KAAK5B,SAAL,CAAe1D,aAAf,CAA6BuF,MAA7B;IACH,CAXmH,CAA7G,EAWH9H,GAAG,CAAC,CAAC,CAAC4H,MAAD,CAAD,KAAcA,MAAf,CAXA,CAAP;EAYH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIG,iBAAiB,CAACf,OAAD,EAAU;IACvB,OAAOhI,KAAK,CAAC,MAAM,KAAK8C,WAAL,CAAiBiG,iBAAjB,CAAmCf,OAAnC,CAAP,CAAZ;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIgB,cAAc,CAAChB,OAAD,EAAU;IACpB,OAAO/H,EAAE,CAAC,KAAK6C,WAAL,CAAiBkG,cAAjB,CAAgChB,OAAhC,CAAD,CAAT;EACH;;EACDN,oBAAoB,GAAG;IACnB,OAAOzH,EAAE,CAACyC,QAAQ,CAACuG,MAAV,CAAF,CAAoBxD,IAApB,CAAyBzE,GAAG,CAAEiI,MAAD,IAAY;MAC5C,OAAQ,CAACA,MAAM,CAACC,QAAP,CAAgB,OAAhB,KAA4BD,MAAM,CAACC,QAAP,CAAgB,QAAhB,CAA7B,KACJD,MAAM,CAACC,QAAP,CAAgB,QAAhB,CADI,IAEJ,CAAC,KAAKrH,aAAL,CAAmBE,GAAnB,GAAyBoH,oBAF9B;IAGH,CAJkC,CAA5B,CAAP;EAKH;;AA/Qa;;AAiRlBnC,WAAW,CAACtD,IAAZ,GAAmB,SAAS0F,mBAAT,CAA6BxF,CAA7B,EAAgC;EAAE,OAAO,KAAKA,CAAC,IAAIoD,WAAV,EAAuB1H,MAAM,CAACuE,QAAP,CAAgBZ,kBAAhB,CAAvB,EAA4D3D,MAAM,CAACuE,QAAP,CAAgBc,gBAAhB,CAA5D,EAA+FrF,MAAM,CAACuE,QAAP,CAAgBX,iBAAhB,CAA/F,EAAmI5D,MAAM,CAACuE,QAAP,CAAgBoB,SAAhB,CAAnI,CAAP;AAAwK,CAA7N;;AACA+B,WAAW,CAAClD,KAAZ,GAAoBjF,EAAE,CAACkF,kBAAH,CAAsB;EAAEC,OAAO,EAAE,SAASoF,mBAAT,GAA+B;IAAE,OAAO,IAAIpC,WAAJ,CAAgBnI,EAAE,CAACgF,QAAH,CAAYZ,kBAAZ,CAAhB,EAAiDpE,EAAE,CAACgF,QAAH,CAAYc,gBAAZ,CAAjD,EAAgF9F,EAAE,CAACgF,QAAH,CAAYX,iBAAZ,CAAhF,EAAgHrE,EAAE,CAACgF,QAAH,CAAYoB,SAAZ,CAAhH,CAAP;EAAiJ,CAA7L;EAA+Lf,KAAK,EAAE8C,WAAtM;EAAmN7C,UAAU,EAAE;AAA/N,CAAtB,CAApB;;AACA6C,WAAW,CAAC5C,cAAZ,GAA6B,MAAM,CAC/B;EAAEC,IAAI,EAAEhF,WAAR;EAAqB2F,UAAU,EAAE,CAAC;IAAEX,IAAI,EAAElF,MAAR;IAAgBqF,IAAI,EAAE,CAACvB,kBAAD;EAAtB,CAAD;AAAjC,CAD+B,EAE/B;EAAEoB,IAAI,EAAEM;AAAR,CAF+B,EAG/B;EAAEN,IAAI,EAAEnB;AAAR,CAH+B,EAI/B;EAAEmB,IAAI,EAAEY;AAAR,CAJ+B,CAAnC;;AAMA,CAAC,YAAY;EAAE,CAAC,OAAOX,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyByC,WAAzB,EAAsC,CAAC;IACjG3C,IAAI,EAAErF,UAD2F;IAEjGwF,IAAI,EAAE,CAAC;MACCL,UAAU,EAAE;IADb,CAAD;EAF2F,CAAD,CAAtC,EAK1D,YAAY;IAAE,OAAO,CAAC;MAAEE,IAAI,EAAE7E,MAAM,CAACH,WAAf;MAA4B2F,UAAU,EAAE,CAAC;QACvDX,IAAI,EAAElF,MADiD;QAEvDqF,IAAI,EAAE,CAACvB,kBAAD;MAFiD,CAAD;IAAxC,CAAD,EAGX;MAAEoB,IAAI,EAAEM;IAAR,CAHW,EAGiB;MAAEN,IAAI,EAAEnB;IAAR,CAHjB,EAG8C;MAAEmB,IAAI,EAAEY;IAAR,CAH9C,CAAP;EAG4E,CARhC,EAQkC,IARlC,CAAnD;AAQ6F,CAR5G;;AAUA,MAAMoE,SAAN,CAAgB;EACZlG,WAAW,CAACmG,IAAD,EAAO;IACd,KAAKA,IAAL,GAAYA,IAAZ;EACH;;EACDC,OAAO,CAACC,KAAD,EAAQC,QAAR,EAAkB;IACrB,OAAO,KAAKH,IAAL,CAAUtD,gBAAV,CAA2BP,IAA3B,CAAgCxE,IAAI,CAAC,CAAD,CAApC,CAAP;EACH;;EACDyI,WAAW,CAACjD,IAAD,EAAOkD,KAAP,EAAc;IACrB,OAAO,KAAKC,yBAAL,CAA+BD,KAA/B,CAAP;EACH;;EACDE,gBAAgB,CAACC,UAAD,EAAaH,KAAb,EAAoB;IAChC,OAAO,KAAKC,yBAAL,CAA+BD,KAA/B,CAAP;EACH;;EACDC,yBAAyB,CAACD,KAAD,EAAQ;IAC7B,OAAO,KAAKL,IAAL,CAAUtD,gBAAV,CAA2BP,IAA3B,CAAgC5E,GAAG,CAAEkJ,QAAD,IAAc;MACrD,IAAI,CAACA,QAAL,EAAe;QACX,KAAKT,IAAL,CAAUvB,iBAAV,CAA4B;UACxBc,QAAQ,EAAE;YAAEC,MAAM,EAAEa,KAAK,CAACnG;UAAhB;QADc,CAA5B;MAGH;IACJ,CANyC,CAAnC,CAAP;EAOH;;AArBW;;AAuBhB6F,SAAS,CAAC3F,IAAV,GAAiB,SAASsG,iBAAT,CAA2BpG,CAA3B,EAA8B;EAAE,OAAO,KAAKA,CAAC,IAAIyF,SAAV,EAAqB/J,MAAM,CAACuE,QAAP,CAAgBmD,WAAhB,CAArB,CAAP;AAA4D,CAA7G;;AACAqC,SAAS,CAACvF,KAAV,GAAkBjF,EAAE,CAACkF,kBAAH,CAAsB;EAAEC,OAAO,EAAE,SAASgG,iBAAT,GAA6B;IAAE,OAAO,IAAIX,SAAJ,CAAcxK,EAAE,CAACgF,QAAH,CAAYmD,WAAZ,CAAd,CAAP;EAAiD,CAA3F;EAA6F9C,KAAK,EAAEmF,SAApG;EAA+GlF,UAAU,EAAE;AAA3H,CAAtB,CAAlB;;AACAkF,SAAS,CAACjF,cAAV,GAA2B,MAAM,CAC7B;EAAEC,IAAI,EAAE2C;AAAR,CAD6B,CAAjC;;AAGA,CAAC,YAAY;EAAE,CAAC,OAAO1C,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyB8E,SAAzB,EAAoC,CAAC;IAC/FhF,IAAI,EAAErF,UADyF;IAE/FwF,IAAI,EAAE,CAAC;MACCL,UAAU,EAAE;IADb,CAAD;EAFyF,CAAD,CAApC,EAK1D,YAAY;IAAE,OAAO,CAAC;MAAEE,IAAI,EAAE2C;IAAR,CAAD,CAAP;EAAiC,CALW,EAKT,IALS,CAAnD;AAKkD,CALjE;;AAOA,MAAMiD,UAAN,CAAiB;EACb;AACJ;AACA;AACA;AACA;EACkB,OAAPC,OAAO,CAACpI,MAAD,EAAS;IACnB,OAAO;MACHqI,QAAQ,EAAEF,UADP;MAEHG,SAAS,EAAE,CACPpD,WADO,EAEPqC,SAFO,EAGP;QACIgB,OAAO,EAAEvF,iBADb;QAEIwF,QAAQ,EAAExI;MAFd,CAHO,EAOP;QACIuI,OAAO,EAAEpH,kBADb;QAEIsH,UAAU,EAAE5I,kBAAkB,CAACC,YAFnC;QAGI4I,IAAI,EAAE,CAAC7F,gBAAD;MAHV,CAPO;IAFR,CAAP;EAgBH;;AAvBY;;AAyBjBsF,UAAU,CAACvG,IAAX,GAAkB,SAAS+G,kBAAT,CAA4B7G,CAA5B,EAA+B;EAAE,OAAO,KAAKA,CAAC,IAAIqG,UAAV,GAAP;AAAiC,CAApF;;AACAA,UAAU,CAACS,IAAX,GAAkB,aAAcpL,MAAM,CAACqL,gBAAP,CAAwB;EAAEtG,IAAI,EAAE4F;AAAR,CAAxB,CAAhC;AACAA,UAAU,CAACW,IAAX,GAAkB,aAActL,MAAM,CAACuL,gBAAP,CAAwB,EAAxB,CAAhC;;AACA,CAAC,YAAY;EAAE,CAAC,OAAOvG,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyB0F,UAAzB,EAAqC,CAAC;IAChG5F,IAAI,EAAEjF;EAD0F,CAAD,CAArC,EAE1D,IAF0D,EAEpD,IAFoD,CAAnD;AAEO,CAFtB;;AAIA,MAAM0L,mBAAN,CAA0B;EACtB3H,WAAW,CAACtB,aAAD,EAAgBiB,WAAhB,EAA6BoE,SAA7B,EAAwC;IAC/C,KAAKrF,aAAL,GAAqBA,aAArB;IACA,KAAKiB,WAAL,GAAmBA,WAAnB;IACA,KAAKoE,SAAL,GAAiBA,SAAjB;EACH;;EACD6D,SAAS,CAACC,GAAD,EAAMvE,IAAN,EAAY;IACjB,IAAInD,EAAJ;;IACA,MAAMxB,MAAM,GAAG,KAAKD,aAAL,CAAmBE,GAAnB,EAAf;;IACA,IAAI,EAAE,CAACuB,EAAE,GAAGxB,MAAM,CAACM,eAAb,MAAkC,IAAlC,IAA0CkB,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAAC2H,WAAxE,CAAJ,EAA0F;MACtF,OAAOxE,IAAI,CAACyE,MAAL,CAAYF,GAAZ,CAAP;IACH;;IACD,OAAO,KAAKG,iBAAL,CAAuBH,GAAvB,EAA4BlJ,MAAM,CAACM,eAAnC,EAAoDqD,IAApD,CAAyD9E,SAAS,CAAE6I,KAAD,IAAWtJ,GAAG,EACxF;IACA,MAAMsJ,KAAK,KAAK,IAFwE,EAGxF;IACA;IACAvJ,EAAE,CAACuJ,KAAD,CAAF,CAAU/D,IAAV,CAAevE,KAAK,CAAC,cAAD,CAApB,EAAsCP,SAAS,CAAEqH,OAAD,IAAa;MACzD,OAAO,KAAKK,sBAAL,CAA4BL,OAA5B,EAAqCvC,IAArC,CAA0C7E,UAAU,CAAEwK,GAAD,IAAS;QACjE,IAAI,KAAKC,cAAL,CAAoB7B,KAApB,EAA2B4B,GAA3B,CAAJ,EAAqC;UACjC,OAAOnL,EAAE,CAAC,EAAD,CAAT;QACH;;QACD,KAAKiH,SAAL,CAAeL,QAAf,CAAwBuE,GAAxB;QACA,OAAOhL,UAAU,CAACgL,GAAD,CAAjB;MACH,CAN0D,CAApD,CAAP;IAOH,CAR8C,CAA/C,EAQI5K,SAAS,CAAE0D,KAAD,IAAW;MACrB;MACA,MAAMoH,KAAK,GAAGpH,KAAK,GACb8G,GAAG,CAACM,KAAJ,CAAU;QACRC,OAAO,EAAEP,GAAG,CAACO,OAAJ,CAAY3G,GAAZ,CAAgB,eAAhB,EAAkC,UAASV,KAAM,EAAjD;MADD,CAAV,CADa,GAIb8G,GAJN;MAKA,OAAOvE,IAAI,CAACyE,MAAL,CAAYI,KAAZ,CAAP;IACH,CARY,CARb,CALwF,EAsBxF;IACA;IACA7E,IAAI,CAACyE,MAAL,CAAYF,GAAZ,CAxBwF,CAAf,CAAlE,CAAP;EAyBH;EACD;AACJ;AACA;AACA;AACA;;;EACI3C,sBAAsB,CAACL,OAAD,EAAU;IAC5B,OAAO/H,EAAE,CAAC,KAAK6C,WAAN,CAAF,CAAqB2C,IAArB,CAA0B9E,SAAS,CAAE2H,MAAD,IAAYA,MAAM,CAACE,gBAAP,CAAwBR,OAAxB,CAAb,CAAnC,EAAmFnH,GAAG,CAAEqD,KAAD,IAAW,KAAKgD,SAAL,CAAeP,cAAf,CAA8BzC,KAA9B,CAAZ,CAAtF,EAAyItD,UAAU,CAAEkG,KAAD,IAAW;MAClK,KAAKI,SAAL,CAAeR,OAAf;MACA,OAAOtG,UAAU,CAAC0G,KAAD,CAAjB;IACH,CAHyJ,CAAnJ,CAAP;EAIH;EACD;AACJ;AACA;AACA;;;EACI0E,cAAc,CAACC,GAAD,EAAM;IAChB,IAAIA,GAAG,CAACC,OAAJ,CAAY,GAAZ,IAAmB,CAAC,CAAxB,EAA2B;MACvBD,GAAG,GAAGA,GAAG,CAACE,MAAJ,CAAW,CAAX,EAAcF,GAAG,CAACC,OAAJ,CAAY,GAAZ,CAAd,CAAN;IACH;;IACD,IAAID,GAAG,CAACC,OAAJ,CAAY,GAAZ,IAAmB,CAAC,CAAxB,EAA2B;MACvBD,GAAG,GAAGA,GAAG,CAACE,MAAJ,CAAW,CAAX,EAAcF,GAAG,CAACC,OAAJ,CAAY,GAAZ,CAAd,CAAN;IACH;;IACD,OAAOD,GAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIG,cAAc,CAACpC,KAAD,EAAQqC,OAAR,EAAiB;IAC3B,MAAMC,aAAa,GAAIC,KAAD,IAAW;MAC7B,IAAI,CAACA,KAAL,EAAY;QACR,OAAO,KAAP;MACH;;MACD,MAAMC,WAAW,GAAG,KAAKR,cAAL,CAAoBK,OAAO,CAACrI,GAA5B,CAApB;;MACA,IAAIuI,KAAK,KAAKC,WAAd,EAA2B;QACvB,OAAO,IAAP;MACH,CAP4B,CAQ7B;;;MACA,OAAQD,KAAK,CAACL,OAAN,CAAc,GAAd,MAAuBK,KAAK,CAACE,MAAN,GAAe,CAAtC,IACJJ,OAAO,CAACrI,GAAR,CAAY0I,UAAZ,CAAuBH,KAAK,CAACJ,MAAN,CAAa,CAAb,EAAgBI,KAAK,CAACE,MAAN,GAAe,CAA/B,CAAvB,CADJ;IAEH,CAXD;;IAYA,IAAIxH,4BAA4B,CAAC+E,KAAD,CAAhC,EAAyC;MACrC,IAAIA,KAAK,CAAC2C,UAAN,IAAoB3C,KAAK,CAAC2C,UAAN,KAAqBN,OAAO,CAACO,MAArD,EAA6D;QACzD,OAAO,KAAP;MACH;MACD;;;MACA,IAAI,CAAC5C,KAAK,CAACiC,GAAP,IAAc,CAACjC,KAAK,CAAC6C,UAAzB,EAAqC;QACjCC,OAAO,CAACC,IAAR,CAAa,+EAAb;MACH;;MACD,OAAO/C,KAAK,CAAC6C,UAAN,GACD7C,KAAK,CAAC6C,UAAN,CAAiBR,OAAO,CAACrI,GAAzB,CADC,GAEDsI,aAAa,CAACtC,KAAK,CAACiC,GAAP,CAFnB;IAGH;;IACD,OAAOK,aAAa,CAACtC,KAAD,CAApB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACI2B,iBAAiB,CAACU,OAAD,EAAU/J,MAAV,EAAkB;IAC/B,OAAO3B,IAAI,CAAC2B,MAAM,CAACmJ,WAAR,CAAJ,CAAyBxF,IAAzB,CAA8BtE,KAAK,CAAEqI,KAAD,IAAW,KAAKoC,cAAL,CAAoBpC,KAApB,EAA2BqC,OAA3B,CAAZ,EAAiD,IAAjD,CAAnC,CAAP;EACH;;EACDR,cAAc,CAAC7B,KAAD,EAAQ4B,GAAR,EAAa;IACvB,OAAQ,CAAC,CAAC5B,KAAF,IACJ/E,4BAA4B,CAAC+E,KAAD,CADxB,IAEJ,CAAC,CAACA,KAAK,CAAC6B,cAFJ,IAGJ,CAAC,gBAAD,EAAmB,kBAAnB,EAAuCnC,QAAvC,CAAgDkC,GAAG,CAACtE,KAApD,CAHJ;EAIH;;AA7GqB;;AA+G1BgE,mBAAmB,CAACpH,IAApB,GAA2B,SAAS8I,2BAAT,CAAqC5I,CAArC,EAAwC;EAAE,OAAO,KAAKA,CAAC,IAAIkH,mBAAV,EAA+BxL,MAAM,CAACuE,QAAP,CAAgBc,gBAAhB,CAA/B,EAAkErF,MAAM,CAACuE,QAAP,CAAgBZ,kBAAhB,CAAlE,EAAuG3D,MAAM,CAACuE,QAAP,CAAgBoB,SAAhB,CAAvG,CAAP;AAA4I,CAAjN;;AACA6F,mBAAmB,CAAChH,KAApB,GAA4B,aAAcxE,MAAM,CAACyE,kBAAP,CAA0B;EAAEG,KAAK,EAAE4G,mBAAT;EAA8B9G,OAAO,EAAE8G,mBAAmB,CAACpH;AAA3D,CAA1B,CAA1C;;AACAoH,mBAAmB,CAAC1G,cAApB,GAAqC,MAAM,CACvC;EAAEC,IAAI,EAAEM;AAAR,CADuC,EAEvC;EAAEN,IAAI,EAAEhF,WAAR;EAAqB2F,UAAU,EAAE,CAAC;IAAEX,IAAI,EAAElF,MAAR;IAAgBqF,IAAI,EAAE,CAACvB,kBAAD;EAAtB,CAAD;AAAjC,CAFuC,EAGvC;EAAEoB,IAAI,EAAEY;AAAR,CAHuC,CAA3C;;AAKA,CAAC,YAAY;EAAE,CAAC,OAAOX,SAAP,KAAqB,WAArB,IAAoCA,SAArC,KAAmDhF,MAAM,CAACiF,iBAAP,CAAyBuG,mBAAzB,EAA8C,CAAC;IACzGzG,IAAI,EAAErF;EADmG,CAAD,CAA9C,EAE1D,YAAY;IAAE,OAAO,CAAC;MAAEqF,IAAI,EAAEM;IAAR,CAAD,EAA6B;MAAEN,IAAI,EAAE7E,MAAM,CAACH,WAAf;MAA4B2F,UAAU,EAAE,CAAC;QACnFX,IAAI,EAAElF,MAD6E;QAEnFqF,IAAI,EAAE,CAACvB,kBAAD;MAF6E,CAAD;IAAxC,CAA7B,EAGX;MAAEoB,IAAI,EAAEY;IAAR,CAHW,CAAP;EAGmB,CALyB,EAKvB,IALuB,CAAnD;AAKoC,CALnD;AAOA;AACA;AACA;;AAEA;AACA;AACA;;;AAEA,SAAStD,kBAAT,EAA6BsB,kBAA7B,EAAiD0B,gBAAjD,EAAmEG,iBAAnE,EAAsFuE,SAAtF,EAAiGyB,mBAAjG,EAAsHb,UAAtH,EAAkIjD,WAAlI,EAA+I/B,SAA/I,EAA0JR,4BAA1J,EAAwLvB,iBAAiB,IAAIuJ,EAA7M"},"metadata":{},"sourceType":"module"}